package com.osm2xp.translators.airfield;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang.StringUtils;

import com.osm2xp.constants.Osm2xpConstants;
import com.osm2xp.model.osm.OsmPolygon;
import com.osm2xp.model.osm.OsmPolyline;
import com.osm2xp.utils.OsmUtils;
import com.osm2xp.utils.geometry.GeomUtils;
import com.osm2xp.utils.helpers.XplaneOptionsHelper;
import com.osm2xp.utils.logging.Osm2xpLogger;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.Polygon;
import com.vividsolutions.jts.operation.buffer.BufferOp;
import com.vividsolutions.jts.operation.buffer.BufferParameters;
import com.vividsolutions.jts.operation.overlay.OverlayOp;

import math.geom2d.Box2D;
import math.geom2d.Point2D;
import math.geom2d.polygon.Polyline2D;

/**
 * Airport data writer for X-Plane
 * Based on apt.dat 10.50 spec - <a>http://developer.x-plane.com/wp-content/uploads/2017/02/XP-APT1050-Spec.pdf</a>
 * @author Dmitry Karpenko
 *
 */
public class XPAirfieldOutput {
	
	private static final String NAV_DATA_FOLDER_NAME = "Earth nav data";
	private static final String OSM2XP_AIRFIELD_PREFFIX = "osm2xp_";
	private static final double METER_TO_FEET_COEF = 3.28084;
	private File baseFolder;
	private boolean writeMainAirfield;
	private int fakeICAOIdx = 0;

	public XPAirfieldOutput(File baseFolder, boolean writeMainAirfield) {
		this.baseFolder = writeMainAirfield ? baseFolder : new File(baseFolder, "airports");;
		this.writeMainAirfield = writeMainAirfield;
		baseFolder.mkdirs();
	}
	
	public List<String> getAptHeaderString() {
		List<String> result = new ArrayList<String>();
		result.add("I");
		result.add("1000 Version - generated by OSM2XP " + Osm2xpConstants.OSM2XP_VERSION);
		result.add("");
		return result;
	}
	
	public void writeAirfield(AirfieldData airfieldData) {
		List<RunwayData> runways = airfieldData.getRunways();
		if (runways.isEmpty()) {
			return; //Do nothing, if no runways assigned for airport
		}
		List<String> defsList = new ArrayList<String>();
		defsList.addAll(getAptHeaderString());
		String icao = checkGetICAO(airfieldData);
		defsList.add(String.format("1 %d 0 0 %s %s",  (int) Math.round(airfieldData.getElevation() * METER_TO_FEET_COEF), icao, airfieldData.getName()));
		for (RunwayData runway : runways) {
			defsList.add(getRunwayStr(runway));
		}
		Polyline2D polygon = airfieldData.getPolygon();
		defsList.addAll(getApronDefs(airfieldData));
		if (polygon != null && polygon.getVertexNumber() > 3) {
			defsList.addAll(getAptAreaDef(icao, airfieldData));		
		}
		defsList.add("99");
		writeAptData(airfieldData.getId(), defsList.toArray(new String[0]));
	}

	private List<? extends String> getApronDefs(AirfieldData airfieldData) {
		List<String> list = new ArrayList<String>();
		try {
			Box2D bbox = airfieldData.getPolygon().getBoundingBox();
			Point2D centerPoint = new Point2D(bbox.getMinX(), bbox.getMinY());
			List<OsmPolygon> apronAreas = airfieldData.getApronAreas();
			List<OsmPolyline> taxiLanes = airfieldData.getTaxiLanes();
			List<Geometry> convertedAreas = apronAreas.stream().
					map(polyline -> GeomUtils.geom2dToJtsLocal(polyline.getPolyline(), centerPoint)).collect(Collectors.toList());
			List<Geometry> convertedLanes = taxiLanes.stream().
					map(polyline -> GeomUtils.geom2dToJtsLocal(polyline.getPolyline(), centerPoint)).collect(Collectors.toList());
			double dist = XplaneOptionsHelper.getOptions().getAirfieldOptions().getDefaultTaxiwayWidth() / 2.0 / 111000;
			BufferParameters bufferParameters = new BufferParameters(4, BufferParameters.CAP_ROUND);
			List<Geometry> bufferedLanes = convertedLanes.stream().map(lane -> buildBufferedLine(dist, bufferParameters, lane)).collect(Collectors.toList());
			List<Geometry> toJoin = new ArrayList<Geometry>(convertedAreas);
			toJoin.addAll(bufferedLanes);
			if (toJoin.size() > 0) {
				Geometry joinResult = toJoin.get(0);
				joinResult = GeomUtils.fix(joinResult);
				for (int i = 1; i < toJoin.size(); i++) {
					Geometry current = toJoin.get(i);
					current = GeomUtils.fix(current);
					joinResult = OverlayOp.overlayOp(joinResult, current, OverlayOp.UNION);
				}
				List<Polygon> apronPolys = GeomUtils.flatMapToPoly(joinResult);
				for (Polygon polygon : apronPolys) {
					list.addAll(getApronDef(airfieldData, polygon, centerPoint));
				}
			}
		} catch (Exception e) {
			Osm2xpLogger.error("Error creating apron area for " + airfieldData.getId() + " airfield");
		}
		return list;
	}

	protected Geometry buildBufferedLine(double dist, BufferParameters bufferParameters, Geometry lane) {
		Geometry buffered = BufferOp.bufferOp(lane, dist, bufferParameters);
		return buffered;
	}

	private List<String> getAptAreaDef(String icao, AirfieldData airfieldData) {
		List<String> resList = new ArrayList<String>();
		if (shouldFlatten(airfieldData)) {
			resList.add("1302 flatten 1"); //If we have no actual elevation - flattening would goof up airfield, 
										   // making it a giant pit with bottom plateu having elevation 0m
										   //TODO obtain necessary elevation using some REST service in future
		}
		resList.add("130 " + icao);
		resList.addAll(getAreaString(airfieldData.getPolygon()));
		return resList;
	}

	protected boolean shouldFlatten(AirfieldData airfieldData) {
		return XplaneOptionsHelper.getOptions().getAirfieldOptions().isFlatten() && airfieldData.hasActualElevation();
	}
	
	private List<String> getApronDef(AirfieldData airfieldData, Polygon polygon, Point2D centerPoint) {
		List<String> resList = new ArrayList<String>();
		String surface = airfieldData.isHard()? "2" : "3";
		String roughness = airfieldData.isHard()? "0.2" : "0.3";
		resList.add("110 " + surface + " " + roughness + " 0.00 Sample" );
		resList.addAll(getAreaString(GeomUtils.jtsToGeom2dLocal(GeomUtils.forceCCW(polygon.getExteriorRing()),centerPoint)));
		for (int i = 0; i < polygon.getNumInteriorRing(); i++) {
			resList.addAll(getAreaString(GeomUtils.jtsToGeom2dLocal(GeomUtils.forceCW(polygon.getInteriorRingN(i)), centerPoint)));	
		}
		return resList;
	}
	
	private List<String> getAreaString(Polyline2D polyline2d) {
		List<String> resList = new ArrayList<String>();
		int n = polyline2d.getVertexNumber();
		if (n < 3) {
			return Collections.emptyList();
		}
		if (polyline2d.getVertex(0).equals(polyline2d.getVertex(n - 1))) {
			n--;
		}
		for (int i = 0; i < n; i++) {
			Point2D coords = polyline2d.getVertex(i);
			if (i < n - 1) {
				resList.add(String.format("111 %1.8f %2.8f", coords.y, coords.x));
			} else {
				resList.add(String.format("113 %1.8f %2.8f", coords.y, coords.x));
			}
		}
		return resList;
	}

	protected String checkGetICAO(AirfieldData airfieldData) {
		String icao = airfieldData.getICAO();
		if (icao == null) {
			icao = "xx" + StringUtils.leftPad(""+ getNextICAOIdx(), 2, '0');
		}
		return icao;
	}
	
	protected String checkGetICAO(RunwayData runwayData) {
		String name = runwayData.getName();
		if (OsmUtils.isValidICAO(name)) {
			return name.toUpperCase().trim();
		}
		return "xx" + StringUtils.leftPad(""+ getNextICAOIdx(), 2, '0');
	}

	private int getNextICAOIdx() {
		return fakeICAOIdx++;
	}

	public void writeSingleRunway(RunwayData runwayData) {
		List<String> defsList = new ArrayList<String>();
		defsList.addAll(getAptHeaderString());
		defsList.add(String.format("1 %d 0 0 %s %s",  (int) Math.round(runwayData.getElevation() * METER_TO_FEET_COEF), checkGetICAO(runwayData), runwayData.getName()));
		defsList.add(getRunwayStr(runwayData));
		defsList.add("99");
		writeAptData(runwayData.getId(), defsList.toArray(new String[0]));
	}
	
	protected void writeAptData(String aptId, String[] aptDefinition) {
		if (aptDefinition.length == 0) {
			return;
		}
		File dataFolder;
		if (writeMainAirfield) {
			dataFolder = new File(baseFolder, NAV_DATA_FOLDER_NAME);
		} else {
			File airfieldFolder = new File(baseFolder, OSM2XP_AIRFIELD_PREFFIX + aptId);
			for (int i = 0; airfieldFolder.exists() && i < Integer.MAX_VALUE; i++) {
				airfieldFolder = new File(baseFolder, OSM2XP_AIRFIELD_PREFFIX + aptId + i);
			}
			dataFolder = new File(airfieldFolder, NAV_DATA_FOLDER_NAME);
		}
		dataFolder.mkdirs();
		try (PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(new File(dataFolder, "apt.dat"))))) {
			for (String string : aptDefinition) {
				writer.println(string);
			}
			
		} catch (IOException e) {
			Osm2xpLogger.error("Error saving apt.dat for airfield " + aptId);
		}
	}

	private String getRunwayStr(RunwayData runway) {
		StringBuilder builder = new StringBuilder("100 ");
		builder.append(String.format("%1.2f", runway.getWidth()));
		builder.append(' ');
		builder.append(getSurfaceCode(runway));
		builder.append(' ');
		builder.append(getSurfaceShoulderCode(runway));
		builder.append(' ');
		builder.append(getRoughness(runway));
		builder.append(' ');
		builder.append(getCenterLights(runway));
		builder.append(' ');
		builder.append(getEdgeLights(runway));
		builder.append(' ');
		builder.append(getDistSigns(runway));
		builder.append(' ');
		builder.append(getEndStr(runway.getMarking1(), runway.getRunwayLine().p1, runway.isHard()));
		builder.append(' ');
		builder.append(getEndStr(runway.getMarking2(), runway.getRunwayLine().p2, runway.isHard()));
		return builder.toString();
	}
	
	private String getEndStr(String marking, Point2D coords, boolean isHard) {
		StringBuilder builder = new StringBuilder(marking);
		builder.append(' ');
		builder.append(String.format("%1.8f %2.8f 0 0 ", coords.y, coords.x));
		builder.append(' ');
		builder.append(getRunwayMarkingCode(isHard));
		builder.append(' ');
		builder.append(getApproachLightingCode(isHard));
		builder.append(' ');
		builder.append(getTGZLightingCode(isHard));
		builder.append(' ');
		builder.append(getREILCode(isHard));
		return builder.toString();
	}
	
	private int getRunwayMarkingCode(boolean isHard) {
		return isHard ? 1 : 0;
	}
	
	private int getTGZLightingCode(boolean isHard) {
		return isHard ? 1 : 0;
	}
	
	private int getREILCode(boolean isHard) {
		return isHard ? 1 : 0;
	}	
	
	private int getApproachLightingCode(boolean isHard) {
		return isHard ? 1 : 0;
	}

	private int getDistSigns(RunwayData runway) {
		return runway.isHard() ? 1 : 0;
	}

	private int getCenterLights(RunwayData runway) {
		return runway.isHard() ? 1 : 0;
	}
	
	private int getEdgeLights(RunwayData runway) {
		return runway.isHard() ? 2 : 0;
	}

	private String getRoughness(RunwayData runway) {
		if (runway.isHard()) {
			return "0.15";
		}
		return "0.25";
	}

	private int getSurfaceShoulderCode(RunwayData runwayData) {
		if (!runwayData.isHard())
			return 0;
		String osmSurfaceType = runwayData.getSurface();
		if ("asphalt".equals(osmSurfaceType))
			return 1;
		if ("concrete".equals(osmSurfaceType) || "paved".equals(osmSurfaceType))
			return 2;
		return 0;
	}

	private int getSurfaceCode(RunwayData runwayData) {
		String osmSurfaceType = runwayData.getSurface();
		if ("asphalt".equals(osmSurfaceType))
			return 1;
		if ("concrete".equals(osmSurfaceType) || "paved".equals(osmSurfaceType))
			return 2;
		if ("earth".equals(osmSurfaceType) || "dirt".equals(osmSurfaceType) || "mud".equals(osmSurfaceType) || "sand".equals(osmSurfaceType)) {
			return 4;
		}
		if ("gravel".equals(osmSurfaceType) || "fine_gravel".equals(osmSurfaceType)) {
			return 5;
		}
		return 3; //grass by default
	}

}
